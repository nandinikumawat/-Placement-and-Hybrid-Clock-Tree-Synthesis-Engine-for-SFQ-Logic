#include "grouping.hpp"
#include "partitioning.hpp"

#include <string>
#include <unordered_set>
#include <fstream>

// TODO: Pick UBFACTOR?
static const int UBFACTOR = 8;

static const std::string HYPERGRAPH_FILE_HEADER = "% Auto-generated by sfqplace";

// Type for hmetis input file to indicate a graph with weighted hyperedges
static const int HYPERGRAPH_TYPE_WEIGHTED_EDGES = 1;

PWayPartitioner::PWayPartitioner(Subgraph *subgraph, int groups) {
    this->subgraph = subgraph;
    this->desiredPartitionCount = groups;

    this->hmetisInputFilename = "hmetis_input_" 
                                + std::to_string(subgraph->getLogicLevel()) 
                                + ".graph";

    this->hewgts = nullptr;
    this->eind = nullptr;
    this->eptr = nullptr;
}

PWayPartitioner::~PWayPartitioner(void) {
    this->freeHMETISStructures();
}

void PWayPartitioner::freeHMETISStructures(void) {
    if (this->hewgts != nullptr) {
        delete [] this->hewgts;
    }

    if (this->eind != nullptr) {
        delete [] this->eind;
    }

    if (this->eptr != nullptr) {
        delete [] this->eptr;
    }

    if (this->partitionedData != nullptr) {
        delete [] this->partitionedData;
    }
}

int PWayPartitioner::doPartition(void) {
    // Use default HMETIS options
    int hmetisOptions[9] = {0, };

    // Map from HMETIS vertex ID to it's connections (hyperedges)
    std::unordered_map<int, std::unordered_set<int>> hyperedges;
    std::vector<int> weights;
    int hyperedgeEndpointCount = 0;

    // First convert the subgraph into the hypergraph format for HMETIS

    // Reserve space in the weights array for at least as many edges as we have
    weights.reserve(this->subgraph->getEdges().size());

    this->nvtxs = this->subgraph->getVertices().size();

    // Create HMETIS-specific IDs starting from 0 for each vertex
    // Store a mapping in both directions between the different IDs
    int nextHID = 0;
    this->hmetisIdsMap.clear();
    this->sgraphIdsMap.clear();
    for (const auto &[sid, vertex] : this->subgraph->getVertices()) {
        this->hmetisIdsMap[sid] = nextHID;
        this->sgraphIdsMap[nextHID++] = sid;
    }

    // Populate the hyperedge map
    for (const SubgraphEdge *edge : this->subgraph->getEdges()) {
        // Get HMETIS-IDs for origin and target
        int originHID = hmetisIdsMap.at(edge->originNode);
        int targetHID = hmetisIdsMap.at(edge->targetNode);

        // Check if a hyperedge already exists from the origin node
        if (hyperedges.find(originHID) != hyperedges.end()) {
            hyperedges.at(originHID).insert(targetHID);
            // Added one element to existing hyperedge
            hyperedgeEndpointCount += 1;
        } else {
            std::unordered_set<int> newHyperedge;

            newHyperedge.insert(targetHID);
            hyperedges[originHID] = newHyperedge;

            // Added 2 elements: one for the origin and one for the target
            hyperedgeEndpointCount += 2;
        }

        // Store weight
        weights[originHID] = edge->weight;
    }
    
    // Set hyperedge count
    this->nhedges = hyperedges.size();

#if LINK_TO_HMETIS // HMETIS is compiled for i386
    // Allocate arrays for HMETIS
    this->freeHMETISStructures();
    this->hewgts = new int[this->nhedges];
    this->eptr = new int[this->nhedges + 1];
    this->eind = new int[hyperedgeEndpointCount];

    // Populate HMETIS data structures
    int eindIndex = 0;
    int eptrIndex = 0;
    for (const auto &[id, hedgeMembers] : hyperedges) {
        this->hewgts[id] = weights[id];

        // Store the starting location of this "eindIndex"th hyperedge
        this->eptr[eptrIndex++] = eindIndex;

        // Store all members of this hyperedge
        for (const int hedgeTarget : hedgeMembers) {
            this->eind[eindIndex++] = hedgeTarget;
        }
    }

    int partitionsCreated;

    HMETIS_PartKway(this->nvtxs, this->nhedges, NULL, this->eptr, this->eind, this->hewgts,
                    this->desiredPartitionCount, UBFACTOR,
                    hmetisOptions, partitionedData, &partitionsCreated);

    return partitionsCreated;
#else
    this->partitionedData = new int[this->nvtxs];

    // We aren't linking to libhmetis, so run the standalone program as a system call
    // First write the hypergraph input to a file for it to read
    this->writeHMETISInput(hyperedges, weights);

    std::cout << "Size:" << sgraphIdsMap.size() << std::endl;

    // Run HMETIS
    return this->invokeHMETIS();
#endif
}

void PWayPartitioner::writeHMETISInput(const std::unordered_map<int, std::unordered_set<int>> &hedges,
                                       const std::vector<int> &weights) {
    // TODO: write data to temporary file in the format HMETIS reads
    std::ofstream out(this->hmetisInputFilename);

    if (!out.is_open()) {
        std::cerr << "Failed to open hmetis input file: hmetis_input.graph" << std::endl;
        exit(1);
    } else {
        out << HYPERGRAPH_FILE_HEADER << std::endl;
        out << "% Hypergraph for subgraph of logic level: " << this->subgraph->getLogicLevel();
        out << std::endl;

        // First write number of hyperedges, vertices, and graph type
        out << this->nhedges << ' ' << this->nvtxs << ' ' << HYPERGRAPH_TYPE_WEIGHTED_EDGES;
        out << std::endl;

        // Now write each hyperedge
        for (const auto &[id, hedgeMembers] : hedges) {
            // Write weight
            out << weights[id];

            // Write origin
            out << ' ' << id;

            // Store all members of this hyperedge
            for (const int hedgeTarget : hedgeMembers) {
                out << ' ' << hedgeTarget;
            }

            out << std::endl;
        }

        out.close();
    }
}

int PWayPartitioner::invokeHMETIS(void) {
    // run khmetis via system call feeding it options and the temporary input file
    // then read the output file partition data and return number of partitions
    std::string hmetisCmd = "./khmetis " + this->hmetisInputFilename 
                            + " " + std::to_string(this->desiredPartitionCount)
                            + " " + std::to_string(UBFACTOR)
                            + " 10 3 2 1 2";
    std::cout << "Running HMETIS with command: " << hmetisCmd << std::endl;

    int ret = system(hmetisCmd.c_str());

    std::string partFilename = this->hmetisInputFilename 
                                + ".part." + std::to_string(this->desiredPartitionCount);
    std::ifstream infile(partFilename);
    if (!infile.is_open()) {
        std::cerr << "Failed to open partition file: " << partFilename << std::endl;
        return -1;
    }

    int hmetisVertexId = 0;
    std::string line;

    while (std::getline(infile, line)) {
        int supercellId = std::stoi(line);
        if (this->sgraphIdsMap.find(hmetisVertexId) == this->sgraphIdsMap.end()) {
            std::cerr << "Vertex ID " << hmetisVertexId << " not found in sgraph map." << std::endl;
        } else {
            int originalNodeId = this->sgraphIdsMap[hmetisVertexId];
            this->verticesToSupercells[originalNodeId] = supercellId;
        }
        
        hmetisVertexId++;
    }

    infile.close();
    std::cout << "Partitioning completed. " << hmetisVertexId << " nodes assigned to super-cells." << std::endl;
    return this->desiredPartitionCount;    
}

std::unordered_map<int, int> PWayPartitioner::getPartitions() {
    return this->verticesToSupercells;
}
